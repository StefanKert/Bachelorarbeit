
\section{Hibernate}
\subsection{Allgemeines}
Die Bibliothek Hibernate ist einer der wohl bekannteste OR-Mapper für Java. Mit Hibernate ist es möglich ein objektorientiertes Datenmodell  auf ein relationales Datenbankmodell zu mappen. Die Bibliothek ist mittlerweile über 10 Jahre alt und wurde unter anderem nach .NET portiert und heißt dort NHibernate. Entwickelt wird sie von Red Hat und steht unter der GNU LGPL zur Verfügung. Das Repository lässt sich auf GitHub unter https://github.com/hibernate/hibernate-orm finden.

\subsection{Auskommentierter Code}
\begin{itemize}
	\item Betreffende Klasse: \textit{BindHelper}
	\item Betreffendes Paket: \textit{org.hibernate.cfg}
\end{itemize}


\SuperPar Code der nicht mehr benötigt wird, wird häufig einfach auskommentiert und bleibt danach über lange Zeit im Quellcode bestehen. Dies wäre jedoch bei den modernen Versionsverwaltungssystemen gar nicht mehr notwendig, da diese eine genaue Auflistung der gelöschten, geänderten oder hinzugefügten Abschnitte anbieten. Es ist mit diesen auch leicht möglich Abschnitte, welche man gelöscht hat, wieder aufzufinden, sowie diese wiederherzustellen. Code der nicht mehr benötigt wird sollte daher einfach gelöscht werden und mit einer vernünftigen Commit Message versehen werden. Im Hibernate Framework ist eine Klasse welche einen solchen auskommentierten Codeabschnitt enthält die \textit{BindHelper} Klasse. Eine sehr problematische Stelle befindet sich in dieser Klasse in Zeile 421. Dort gibt es folgenden Codeausschnitt:

\begin{lstlisting}[language=Java, caption=Beispiele für die Verwendung von \textit{GetByPredicate}, label=lst:GetByPredicate]
/*FIXME cannot use subproperties becasue the caller needs top level properties
//if (property.isComposite()) {
//	Iterator subProperties = ((Component)property.getValue()).getPropertyIterator();
// 	while (subProperties.hasNext()) {
//  	matchColumnsByProperty(((Property)subProperties.next()), columnsToProperty);
// 	}
}*/ 
\end{lstlisting}

Der Kommentar deutet darauf hin, dass es in diesem Codeabschnitt einen Fehler gibt der behoben werden müsste. Anstatt diesen Fehler zu beheben wurde der Code einfach auskommentiert und nach einigen Wochen weiß niemand mehr, dass es diesen Fehler gibt. Hier sollte entweder in einem Issue Tracking System genau mitdokumentiert werden, wo der Fehler auftritt und welche Möglichkeiten es gibt diesen zu beheben oder der Fehler, wenn möglich, direkt zu beheben. Diesen einfach stehen zu lassen und die fehlerhafte Codestelle auszukommentieren ist dabei wohl der schlechteste Weg, da so der Fehler nicht mehr auftreten wird und er somit vergessen wird, wodurch sich vermutlich weitere Probleme ergeben.
 
\subsection{Unleserliche boolsche Ausdrücke}
\label{cha:BadBoolStatements}
\begin{itemize}
	\item Betreffende Klasse: \textit{AbstractPropertyHolder}
	\item Betreffendes Paket: \textit{org.hibernate.cfg}
\end{itemize}

\SuperPar Ein weiteres sehr oft auftretendes Problem sind sehr komplexe boolsche Ausdrücke. Oft wird auf Grund ihrer Komplexität ein Kommentar hinzugefügt, welcher Aufschluss darüber geben sollte, was genau gewünscht ist. Jedoch ist die Komplexität meist nicht das einzige Problem. Hierzu ist die \textit{AbstractPropertyHolder} Klasse ein sehr gutes Beispiel.

\begin{lstlisting}[language=Java, caption=Komplexe boolsche Ausdrücke 1 Zeile 255 - 264, label=lst:GetByPredicate]
	@Override
	public JoinColumn[] getOverriddenJoinColumn(String propertyName) {
		JoinColumn[] result = getExactOverriddenJoinColumn( propertyName );
		if ( result == null && propertyName.contains( ".collection&&element." ) ) {
			//support for non map collections where no prefix is needed
			//TODO cache the underlying regexp
			result = getExactOverriddenJoinColumn( propertyName.replace( ".collection&&element.", "."  ) );
		}
		return result;
	}
\end{lstlisting}

Ein paar Zeilen weiter in derselben Klasse findet sich folgende Methode:

\begin{lstlisting}[language=Java, caption=Komplexe boolsche Ausdrücke 2 Zeile 305 - 313, label=lst:GetByPredicate]
public JoinTable getOverriddenJoinTable(String propertyName) {
	JoinTable result = getExactOverriddenJoinTable(propertyName);
	if(result == null 
		&& propertyName.contains(".collection&&element.")){
		//support for non map collections where no prefix is needed
		//TODO cache the underlying regexp
		result = getExactOverriddenJoinTable( propertyName.replace( ".collection&&element.", "."  ) );
	}
	return result;
}
\end{lstlisting}

Konkret geht es in diesem Beispiel um folgenden boolschen Ausdruck, welcher in dieser Klasse insgesamt drei mal verwendet wird.

\begin{lstlisting}[language=Java, caption=Boolscher Audruck, label=lst:GetByPredicate]
result == null && propertyName.contains(".collection&&element.")
\end{lstlisting}

Wie man anhand dieser beiden Listenings leicht erkennen kann, wird dieser Ausdruck in beiden Methoden verwendet. Das heißt, es handelt sich hier im Grunde genommen um Code Duplizierung. Ein weiteres Problem, welches sich hier wie bereits oben beschrieben ergibt, ist die Tatsache, dass dieser boolsche Kommentar ohne einen Kommentar oder ein genaues Lesen nicht sehr leicht zu verstehen ist. Man könnte hier beide Probleme beseitigen, in dem man aus dem boolschen Audruck eine eigene Methode extrahiert. Dabei wird hier nur der zweite Teil des boolschen Ausdrucks extrahiert, da der erste Teil mit dem Nullcheck spezifisch für die einzelnen Methoden verwendet werden muss. Eine solche Methode könnte möglicherweise folgendermaßen aussehen:

\begin{lstlisting}[language=Java, caption=Boolscher Ausdruck neu, label=lst:GetByPredicate]
private bool isPlaceholderForCollectionAndElementInPropertyName(String propertyName) {
	return propertyName.contains(".collection&&element.");
}
\end{lstlisting}

Durch ein Extrahieren der Überprüfung des Parameters \textit{propertyName} kann für diese Methode ein eigener Name gewählt werden, der klar machen sollte, welchen Zweck diese Überprüfung hat. Durch diese eigene Methode wird außerdem die Codeduplizierungen eliminiert und es bleibt nur noch die Sicherheitsüberprüfung auf null.

\subsection{Fazit}
Auch beim Hibernate Framework merkt man, dass es bereits seit einigen Jahren entwickelt wird. Im Grunde genommen wirkt es sehr ausgereift und auch sehr durchdacht. Einige Dinge, wie überflüssige Kommentare, auskommentierter Codeabschnitte, aber auch Codeduplizierungen könnten vermieden werden, in dem man kleinere Refactorings vornimmt. Was besonders positiv auffällt ist, dass selbst die Testsuite sehr sauber gehalten wurde und das auch dort auf Clean Code Richtlinien geachtet wurde. 
