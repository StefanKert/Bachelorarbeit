\chapter{Grundlagen von CCD}
\label{cha:GrundlagenVonCCD}

\SuperPar In diesem Abschnitt sollten die Grundlagen für die unterschiedlichen Praktiken des CCD erläutert werden. Um den Rahmen dieser Arbeit nicht zu sprengen, werden hier nur die zentralsten Praktiken erläutert. Auf Grund der Tatsache, dass sich der dritte Teil dieser Arbeit in erster Linie mit dem Refactoring von Open Source Frameworks hinsichtlich der CCD Praktiken beschäftigt, werden die Beispiele in diesem Abschnitt kurz gehalten und sollten nur als kurze Einführung dienen.

\section{Namensgebung}

Eine der häufigsten Aufgaben eines Programmierers ist das vergeben von Namen. Variablen, Methoden, Klassen, Module, Bibliotheken, Programme. Alle diese Teile brauchen Namen und diese Namen sollten möglichst aussagekräftig sein. Eine Bibliothek die zum Loggen von Informationen wird, sollte im besten Fall das Wort Logging beinhalten, damit sich der Verwender dieser Bibliothek beim ersten Blick darauf schon eine Ahnung hat was sich darin befinden wird und er sich schon einen ersten Eindruck machen kann, was ihn in dieser Bibliothek erwartet.

\SuperPar Im CCD gibt es für die Namensgebung eine grundlegende Regel: Der Name sollte der Größe des Gültigkeitsbereich entsprechen. Wenn man z.B. eine Methode, die in einem globalen Kontext gültig ist, sollte einen dementsprechend deskriptiven Namen aufweisen. Zu beachten ist natürlich auch der Kontext in dem sich diese  befinden, wofür die Methode verwendet werden sollte. Hier nun ein kleines Beispiel. In einem fiktiven Projekt gibt es folgende zentrale Klasse mit einer globalen Property.

\lstset{style=sharpc}
\begin{lstlisting}
public static class Globals {
		public static string Information {get; set;}
}
\end{lstlisting}

Trotz der Kürze dieser Klasse ergibt sich bereits ein Problem. Aus dem Namen der Property kann man die Aufgabe dieser in keinster Weise ablesen. Es wird irgendeine Information gespeichert, doch welche Information genau wird gespeichert und wozu wird diese verwendet? Ein Blick auf die Verwendungen dieser Variable, führt zu der Erkenntnis, dass die Information die Version des Programmes darstellt. Der Programmierer hätte diese Verwirrung vermeiden können indem er die Namen anders gewählt hätte. Hier ein Beispiel zu einer besseren Variante:

\lstset{style=sharpc}
\begin{lstlisting}
public static class ApplicationInformation {
		public static string Version {get; set;}
}
\end{lstlisting}

Durch eine Umbenennung der Klasse wird es auch um einiges klarer, auf welchen Teil des Programmes sich die Version bezieht. Man könnte jetzt noch den Datentyp Version implementieren, welcher die z.B. die Major-, Minor- und Patchnummer beinhaltet:

\lstset{style=sharpc}
\begin{lstlisting}
public static class ApplicationInformation {
		public static Version Version {get; set;}
}

public class Version {
	public int Major { get; set;}
	public int Minor { get; set;}
	public int Patch { get; set;}
}
\end{lstlisting}

Bei diesem letzten Beispiel kann man ohne viele Schritte erkennen, welche Aufgabe dieser Variable zu Teil wird. Durch die Erweiterung um einen eigenen Datentyp ist es jetzt auch leichter weitere Dinge zur Version hinzuzufügen. Angenommen eine zukünftige Anforderung für das Programm verlangt es, bei der Versionsnummer immer die Buildnummer mit anzugeben. Mit der letzten Variante ist dies kein Problem und es kann auch explizit darauf zugegriffen werden, ohne dass man wie bei der ersten Variante die Zeichenkette aufteilen muss.

\section{Methoden}
Eine weitere wichtige grundsätzliche Regel im CCD ist es Funktionen und Methoden möglichst klein zu halten. Es sollte darauf geachtet werden, dass diese dabei das sogenannte Single responsibility principle (kurz SRP) befolgen. Dieses Prinzip besagt, dass alle Aspekte des Softwareentwurfs so geplant werden sollten, sodass sie nur eine Aufgabe erfüllen. Wenn dieses Prinzip für Funktionen und Methoden befolgt wird, sollten diese automatisch sehr klein werden. Wenn eine Methode oder eine Funktion sehr lange ist, deutet dies meist auf eine Verletzung dieses Prinzips hin. Ein weiterer guter Indikator ist die Schwierigkeit mit der man eine Methode oder Funktion testen kann. 

\section{Klassen}