\chapter{Clean Code Development}
\section{Was ist Clean Code?}
\label{cha:WhatIsCleanCode}

Um die Bedeutung von Clean Code zu klären, hat Robert C. Martin mehrere bekannte Softwareentwickler befragt und deren Zitate in seinem Buch Clean Code \cite{Martin2008} aufgelistet. Im Folgenden sollen die wichtigsten Punkte aus den verschiedenen Zitaten wiedergegeben werden, da sie sehr zentrale Aussagen zum Thema Clean Code darstellen. Die folgenden Zitate sind dem Buch Clean Code \cite{Martin2008} entnommen.

\subsubsection{Bjarne Stroustrup}
Der Erfinder von C++ Bjarne Stroustrup spricht davon, dass für ihn Clean Code folgende Punkte erfüllen sollte:

\begin{itemize}
	\item Elegant
	\item Effizient
	\item Gradlinige Logik
	\item Minimale Abhängigkeiten
	\item Vordefinierte Strategie für Fehlerbehandlung
	\item Leistungsverhalten optimieren
\end{itemize}

Bjarne Stroustrup spricht mit diesen Punkten bereits einige sehr zentrale Aspekte des CCD an. Für ihn sollte Code elegant sein. Robert C. Martin teilt diese Meinung und geht dabei noch einen Schritt weiter und schreibt davon, dass guter Code einen Ausdruck des Wohlgefallens auf das Gesicht des Lesers zaubern sollte. Ein weiterer sehr wichtiger Aspekt, den Bjaren Stroustrup erwähnt, ist die Optimierung des Leistungsverhaltens. Diese Optimierung ist daher von großer Bedeutung, da es im Fall von Performanceproblemen meist nicht einfach möglich ist dieses Problem zu beheben. Wie bereits in Abschnitt \ref{cha:Problemstellung} erläutert, wird in solchen Fällen häufig versucht, einen Workaround zu finden, was häufig zu einer schlechteren Wartbarkeit und verschlechterten Lesbarkeit des Codes führt.

\subsubsection{Grady Booch}
Grady Booch ist einer der Autoren des Buches \textit{Object-Oriented Analysis and Design with Applications} \cite{Booch2004} und hält sich mit seinem Zitat zu Clean Code sehr kurz. Er beschreibt, dass sich Clean Code wie wohlgeschriebene Prosa lesen sollte, ähnlich wie ein gutes Buch. Der Quellcode sollte keine Überraschungen für den Leser bringen und auch nicht den eigentlichen Zweck des Codes verschleiern. Wie auch Bjarne Stroustrup schreibt Grady Booch davon, dass Code geradlinig geschrieben sein sollte, wobei er sich dabei explizit auf Kontrollstrukturen bezieht.

\subsubsection{Dave Thomas}
Für Dave Thomas, den Gründer von \textit{Object Technology International} \cite{Thomas2016},  sind folgende Punkte ausschlaggebend für Clean Code:

\begin{itemize}
	\item Lesbar und gut zu verbessern von \textbf{anderen} ProgrammiererInnen
	\item Vorhandensein von Unit- und Acceptance Tests
	\item Bedeutungsvolle Namen
	\item Eine Lösung für eine Aufgabe
	\item Klares und minimales API
\end{itemize}

Das der Code gut lesbar und gut zu verbessern sein sollte wurde bereits mehrmals erwähnt und ist einer der wichtigsten Punkt von CCD. Vor allem die Tatsache, dass er dies auch für andere ProgrammiererInnen sein sollte ist von sehr hoher Bedeutung. Im Gegensatz zu Bjarne Stroustrup erwähnt er auch das Vorhandensein von Unit- und Acceptance Tests. Auch dieser Punkt ist ein sehr zentraler im CCD, da es ohne Tests nur sehr aufwendig möglich ist, die Funktionalität des Codes zu überprüfen. Durch die schwerere Überprüfbarkeit der Funktionalität des Codes wird sehr oft davor zurückgescheut, diesen zu ändern, wodurch er seltener verbessert wird.

\subsubsection{Michael Feathers}
Der Autor des Buches \textit{Working Effectively with Legacy Code} \cite{Feathers2013} beschreibt in seiner Meinung zu Clean Code, dass es für ihn eine alles übergreifende Qualität gibt die andere Punkte überragt (\cite[Seite 36]{Martin2008}): 

\begin{quotation}
	Sauberer Code sieht immer so aus, als wäre er von jemanden geschrieben worden, dem dies wirklich wichtig war. Es fällt nichts ins Auge, wie man den Code verbessern könnte. Alle diese Dinge hat der Autor des Codes bereits selbst durchdacht; und wenn Sie versuchen, sich Verbesserungen vorzustellen, landen Sie wieder an der Stelle, an der Sie gerade sind.
\end{quotation}

Dieses Zitat gibt sehr gut wieder, welchen Wert guter Code haben kann. Michael Feathers streicht dabei einen sehr wichtigen Punkt im Zusammenhang mit Clean Code heraus: Man sollte beim Lesen des Codes bemerken, dass es dem Autor wichtig war und, dass sich der Autor Gedanken darüber gemacht hat, während er diesen geschrieben hat. Der Code sollte mit Sorgfalt geschrieben werden.

\subsubsection{Ron Jeffries}
Ein weiteres Zitat ist von Ron Jeffries (\cite{Jeffries2000}, \cite{Jeffries2004}). Er fasst dabei die für ihn wichtigsten Punkte folgendermaßen zusammen:

\begin{itemize}
	\item Es werden alle Tests bestanden
	\item Er enthält keine Duplizierungen
	\item Es werden die Architektur bzw. Designentscheidungen gut wiedergegeben
	\item Die Anzahl von Klassen und Methoden werden minimiert
	\item Ausdruckskraft
\end{itemize}

Wie bereits in anderen Zitaten zu Clean Code erwähnt, ist die Ausdruckskraft ein sehr zentraler Aspekt des CCD. Dabei geht es zum Beispiel um die Auswahl bedeutungsvoller Namen. Ron Jeffries erwähnt dabei, dass er die von ihm ausgewählten Namen mehrfach ändert, bis er die finale Version hat. Weiters zeigt er eine sehr wichtige Möglichkeit auf, die sich durch die ständige Weiterentwicklung der modernen Entwicklungsumgebungen wie Visual Studio und Eclipse aufgetan hat. Es ist sehr einfach möglich Namen zu ändern, ohne dass viele manuelle Änderungen vorgenommen werden müssen. Eine Namensänderung erfolgt über einen einfachen Befehl und die Entwicklungsumgebung übernimmt das Umbenennen aller Referenzen auf diesen Namen. Eine weitere Möglichkeit, die Ron Jeffries im Zusammenhang mit modernen Entwicklungsumgebungen erwähnt, ist das Extrahieren von Methoden. Falls eine Methode mehr als einen Zweck erfüllt und aufgespalten werden muss, ist dies mit dem \textit{Extract Method} Befehl in modernen Entwicklungsumgebungen sehr einfach. Durch diese Möglichkeiten wird das Refactoring von Quellcode sehr stark vereinfacht, wodurch es schlussendlich leichter möglich ist Clean Code zu schreiben. Im Abschnitt \ref{cha:UsefullTools} wird noch näher auf die Möglichkeiten mit modernen Tools in der Softwareentwicklung eingegangen. Ron Jeffries schließt seine Aussage mit folgendem Zitat ab, welches die einzelnen von ihm angesprochenen Punkte sehr gut zusammenfasst (\cite[Seite 38]{Martin2008}):

\begin{quotation}
Reduzierung der Duplizierung, Steigerung der Ausdruckskraft und frühe Formulierung einfacher Abstraktionen machen für mich sauberen Code aus.
\end{quotation}

\subsubsection{Ward Cunningham}
Ward Cunningham ist nicht nur der Erfinder des Wikis \cite{Wiki2016} und von Fit \cite{Fit2016}, er ist auch Miterfinder des eXtreme Programming \cite{Beck2005} und treibende Kraft hinter den Design Patterns. Sein Zitat sollte hier wortwörtlich wiedergegeben werden, da es die Grundlagen von Clean Code sehr gut wiedergibt (\cite[Seite 39]{Martin2008}):

\begin{quotation}
	Sie wissen, dass Sie an sauberem Code arbeiten, wenn jede Routine, die Sie lesen, ziemlich genau so funktioniert, wie Sie es erwartet haben. Sie können den Code auch >>schön<< nennen, wenn er die Sprache so aussehen lässt, als wäre sie für das Problem geschaffen worden.
\end{quotation}

Dieses Zitat fasst sehr passend zusammen was Clean Code bedeutet. Code der genau so funktioniert, wie man es erwartet. Eine sehr einfache Regel die jedoch meist nicht sehr einfach umzusetzen ist. Meist ist ein Indikator für das Missachten dieser Regel, die Notwendigkeit einen erklärenden Kommentar zu schreiben. Code der genau so funktioniert, wie man es erwartet wird nahezu keine Kommentare benötigen, da es keine unerwarteten Überraschungen für den Leser geben wird. Robert C. Martin streicht besonders den Teil der Aussage hervor, der sich auf die Schönheit des Codes bezieht und ergänzt folgenden Satz  (\cite[Seite 40]{Martin2008}):

\begin{quotation}
Es ist nicht die Sprache, die ein Programm einfach aussehen lässt. Es ist der Programmierer, der die Sprache einfach aussehen lässt.
\end{quotation}

Er bezieht sich dabei auf die Ausrede vieler ProgrammiererInnen, dass die Sprache nicht für die Probleme konzipiert wurde, welche sie lösen sollte. Es ist jedoch die Aufgabe des/der Programmierers/Programmiererin den Code so zu gestalten, dass es so aussieht, als wäre genau dies der Fall.

\newpage
\section{Smells und Heuristiken}
Robert C. Martin beschreibt in seinem Buch \textit{Clean Code} eine Liste von Smells und Heuristiken. Dabei handelt es sich bei Smells um Probleme, die beim Schreiben von Code auftreten können und Heuristiken sind Lösungen für bekannte Probleme. In den folgenden Abschnitten werden diese in Listen gruppiert dargestellt. Es wird dabei nicht zwischen Smells und Heuristiken unterschieden. Smells und Heuristiken, welche in Kapitel \ref{cha:Anwendung} beschrieben werden, sind in dieser Liste fett gekennzeichnet.

\subsubsection{Kommentare}
\begin{itemize}
	\item Name
	\item Ungeeignete Informationen
	\item \textbf{Überholte Kommentare} 
	\item \textbf{Redundante Kommentare}
	\item Schlecht geschriebene Kommentare  
	\item \textbf{Auskommentierter Code}
\end{itemize}

\subsubsection{Umgebung}
\begin{itemize}
	\item Name
	\item Ein Build erfordert mehr als einen Schritt 
	\item Tests erfordern mehr als einen Schritt 
\end{itemize}

\subsubsection{Funktionen}

\begin{itemize}
	\item Name 
	\item \textbf{Zu viele Argumente}
	\item Output-Argumente 
	\item \textbf{Flag-Argumente}
	\item Tote Funktionen 
\end{itemize}

\subsubsection{Allgemein}

\begin{itemize}
			\item Name
			\item Mehrere Sprachen in einer Quelldatei 
			\item Offensichtliches Verhalten ist nicht implementiert 
			\item Falsches Verhalten an den Grenzen 
			\item Übergangene Sicherungen 
			\item \textbf{Duplizierung} 
			\item Auf der falschen Abstraktionsebene codieren 
			\item Basisklasse hängt von abgeleiteten Klassen ab
			\item Zu viele Informationen 
			\item Toter Code 
			\item Vertikale Trennung 
			\item Inkonsistenz 
			\item Müll 
			\item Künstliche Kopplung 
			\item Funktionsneid 
			\item Selektor-Argumente 
			\item Verdeckte Absicht 
			\item Falsche Zuständigkeit 
			\item Fälschlich als statisch deklarierte Methode 
			\item Aussagekräftige Variablen verwenden 
			\item Funktionsname sollte die Aktion ausdrücken 
			\item Den Algorithmus verstehen 
			\item Logische Abhängigkeiten in physische umwandeln 
			\item \textbf{Polymorphismus statt If/Else oder Switch/Case verwenden}
			\item Konventionen beachten 
			\item \textbf{Magische Zahlen durch benannte Konstanten ersetzen}
			\item Präzise sein 
			\item Struktur ist wichtiger als Konvention 
			\item Bedingungen einkapseln 
			\item Negative Bedingungen vermeiden 
			\item Eine Aufgabe pro Funktion!
			\item Verborgene zeitliche Kopplungen 
			\item Keine Willkür 
			\item Grenzbedingungen einkapseln 
			\item In Funktionen nur eine Abstraktionsebene tiefer gehen 
			\item Konfigurierbare Daten hoch ansiedeln 
			\item Transitive Navigation vermeiden
\end{itemize}

\subsubsection{Namen}

\begin{itemize}
			\item Name
			\item \textbf{Deskriptive Namen wählen}
			\item Namen sollten der Abstraktionsebene entsprechen 
			\item Möglichst die Standardnomenklatur verwenden 
			\item Eindeutige Namen 
			\item Lange Namen für große Geltungsbereiche 
			\item Codierungen vermeiden 
			\item Namen sollten Nebeneffekte beschreiben
\end{itemize}

\subsubsection{Tests}

\begin{itemize}
	\item Name 
	\item Unzureichende Tests 
	\item Ein Coverage-Tool verwenden 
	\item Triviale Tests nicht überspringen 
	\item Ein ignorierter Test zeigt eine Mehrdeutigkeit auf 
	\item Grenzbedingungen testen 
	\item Bei Bugs die Nachbarschaft gründlich testen 
	\item Das Muster des Scheiterns zur Diagnose nutzen 
	\item Hinweise durch Coverage-Patterns 
	\item Tests sollten schnell sein 
\end{itemize}

\subsubsection{Zusätzliche Smells und Heuristiken}
Robert C. Martin hat einige in seinem Buch beschriebenen Regeln für Clean Code in seiner abschließenden Liste nicht aufgenommen. Diejenigen Regeln, die in den Anwendungsbeispielen in Kapitel \ref{cha:Anwendung} gezeigt werden, sind hier noch aufgelistet.

\begin{itemize}
	\item \textbf{Keine Null zurückgeben}
	\item \textbf{Ausnahmen sind besser als Fehler-Codes}
	\item \textbf{Duplizierung boolscher Ausdrücke}
	\item \textbf{Duplizierung von Testcode}
	\item \textbf{Try/Catch - Blöcke extrahieren}
\end{itemize}

\section{Die Pfadfinder-Regel}
Eine der bedeutendsten Regeln im CCD ist die sogenannte Pfadfinder-Regel. Robert C. Martin definiert diese wie folgt (\cite[Seite 43]{Martin2008}):

\begin{quote}
	Hinterlasse den Campingplatz sauberer, als du ihn gefunden hast.
\end{quote}

Auf die Arbeit eines Programmierers/einer Programmiererin umgemünzt bedeutet dieser Leitsatz, dass jeder Quellcode, den man betrachtet, verbessert werden sollte. Dies muss nicht unbedingt in einer Änderung der Struktur resultieren. Es reicht meist schon aus, wenn für eine Variable ein besserer Name vergeben, oder ein unnötiger Kommentar entfernt wird. Robert C. Martin schreibt weiters, dass sich durch dieses Vorgehen ein für die Softwareentwicklung ungewöhnlicher Trend ergibt. Der Quellcode wird über die Zeit besser. 

\section{Nutzen moderner Werkzeuge zur Softwareentwicklung}
\label{cha:UsefullTools}
Etwas das Robert C. Martin in seinem Buch kritisiert, ist die Tatsache, dass viele ProgrammiererInnen, die modernen Werkzeuge die ihnen zur Verfügung stehen, nicht nutzen. Durch die Wahl der richtigen Tools und das Verwenden dieser, können viele Schritt, wie das Testen oder das Erstellen einer Software, automatisiert werden. Im Abschnitt \ref{cha:CommentedCode} wird auf ein Problem eingegangen, welches durch die Verwendung eines Versionsverwaltungssystems nicht entstehen würde.

\subsection{Testen, Erzeugen und Verteilen von Software}
In der modernen Softwareentwicklung spricht man oft von \textit{Continuous Delivery}. Dabei geht es um die azyklische Auslieferung einer Software. Es wird dabei eine Pipeline eingerichtet, welche die einzelnen Aufgaben, die für die Auslieferung von Software nötig sind, ausführt. In dem Buch \textit{Continuous Delivery} \cite{Wolff2014} von Eberhard Wolff erläutert der Autor seine Gedanken zum Automatisieren des Prozesses der Erstellung einer Software, über das Testen bis hin zur Auslieferung dieser. Dies sollte für das Team möglichst einfach möglich sein und einmalig eingerichtet, für jeden zugänglich sein, sodass man möglichst schnell eine Rückmeldung erhält, ob die aktuellen Änderungen Probleme verursacht haben. Dies sollte für das Team über eine sogenannte \textit{Continuous Integration} (z.B. Jenkins \cite{Jenkins2016}) Komponente möglich sein.

\SuperPar Der automatische Prozess des Erzeugens und des Testens sollte jedoch nicht nur über die \textit{Continuous Integration} Komponente ermöglicht werden. Es sollte für jeden Programmierer/jede Programmiererin durch wenige Schritte möglich sein, die Software zu Erzeugen und die Tests auch auszuführen. Dies sollte möglichst durch einen einzigen Befehl, durch einen einzigen Klick, oder wenn möglich sogar automatisiert erledigt werden. Mit modernen Entwicklungsumgebungen wie Visual Studio oder Eclipse sind meist schon Werkzeuge integriert, welche das Erstellen und das Testen von Software durch eine einfache Tastenkombination oder einen einzelnen Klick ermöglichen. Diese Features sollten daher auch verwendet werden.

\subsection{Werkzeuge für das Refactoring}
Nahezu alle modernen Entwicklungsumgebungen bieten Möglichkeiten für ein effizientes und einfaches Ändern von Namen. Dabei übernimmt die Entwicklungsumgebung alle Aufgaben, die für eine korrekte Umbenennung nötig sind. Alle Referenzen werden umbenannt, teilweise werden sogar in Kommentaren Namen geändert die auf diesen Namen verweisen. Durch dieses Feature ist es nicht mehr nötig, eine Umbenennung manuelle durchzuführen, da dies meist zu zahlreichen Fehlern führt. Ein weiteres, für das Anwenden von CCD sehr wichtiges Feature, ist das Extrahieren von Methoden. Dabei kann ein beliebiges Stück Code in einer Methode ausgewählt werden und in eine eigene Methode extrahiert werden. Es werden automatisch alle benötigten Variablen als Parameter für die neue Methode angegeben und wenn nötig auch ein Rückgabewert definiert. Dieses Feature ist vor allem bei einem Refactoring von großen Methoden sehr hilfreich.


\subsection{Coding Conventions}
\label{cha:CodingConventions}
Coding Conventions sind ein sehr effizientes Mittel um projektweite, oder auch unternehmensweite Regeln zu definieren, wie einzelne Aspekte der Programmierung gestaltet werden sollten. Vor allem für Open Source Projekte ist dies ein sehr wichtiges Mittel, wie ein durchgängiger Codierungsstil gewählt werden kann. Meist werden auch für Frameworks Coding Conventions definiert wie zum Beispiel für C\# \cite{Microsoft2016}. Oft werden diese grundlegenden Konventionen von Unternehmen verwendet und nur teilweise angepasst, da es durch einen durchgängigen Programmierstil leichter ist, dass sich neue ProgrammiererInnen in die Codebasis einarbeiten. Ein wichtiger Aspekt der bei Coding Conventions beachtet werden muss, ist die Möglichkeit der automatischen Überprüfung dieser. Dazu werden in Abschnitt \ref{cha:CheckingCCDCriterias} einige Möglichkeiten erläutert, wie die Überprüfung dieser Regeln erfolgen kann.

 
\subsection{Überprüfung der CCD Regeln}
\label{cha:CheckingCCDCriterias}
Häufig stellt sich beim CCD die Frage, wie es möglich ist die einzelnen Regeln zu überprüfen. Hierzu gibt es verschiedene Varianten. Es gibt einerseits die statische Codeanalyse, welche dafür Sorgen kann, dass die in Abschnitt \ref{cha:CodingConventions} beschriebenen Coding Conventions eingehalten werden. Ein sehr wirksames Mittel für die Überprüfung des Quellcodes sind Coding Reviews. Es sollte in den folgenden Abschnitten näher auf diese beiden Werkzeuge eingegangen werden.

\subsubsection{Statische Codeanalyse}
Die statische Codeanalyse ist eine Möglichkeit zur Analyse des Quellcodes nach fix vorgegebenen Regeln. Dabei werden für ein Unternehmen oder für ein Projekt die im Abschnitt \ref{cha:CodingConventions} beschriebenen Coding Conventions festgelegt und an Hand dieser werden Regeln definiert, die von diesem Tool automatisch geprüft werden. Ein Beispiel für solch eine Regel wäre das in C\# übliche \textit{I} vor einem Interfacenamen. Bei der statischen Codeanalyse würde im Falle einer Missachtung dieser Regel eine Warnung ausgeben werden und der Programmierer/die Programmiererin würde direkt darauf aufmerksam gemacht werden, dass er/sie sich nicht an die Coding Conventions hält. Im .NET Bereich ist das wohl bekannteste statische Codeanalyse Tool NDepend (\cite{NDepend2016}). Mit diesem ist es neben dem Überprüfen der Coding Conventions auch möglich, zirkuläre Abhängigkeiten zwischen Klassen zu erkennen, die zyklische Komplexität von Methoden zu analysieren und viele weitere Metriken zu erzeugen, die Aufschluss darüber geben, wie sauber der analysierte Code ist. Im Java Bereich gibt es das sehr hilfreiche Tool JDepend (\cite{JDepend2016}), welches ähnlich aufgebaut ist wie NDepend. Vor allem im Webbereich haben sich in den letzten Jahren statische Codeanalysetools etabliert. Im JavaScript Bereich ist vor allem JSHint (\cite{JSHint2016})  und JSLint (\cite{JSLint2016}) sehr populär. 

\subsubsection{Code Reviews}
Code Reviews sind ein sehr wirksames Mittel um geschriebenen Code zu überprüfen. Es handelt sich bei diesen Reviews um manuelle Überprüfungen, die meist von erfahreneren Programmierern/Programmiererinnen vorgenommen werden. Dabei ist einer der wichtigsten Punkte, dass das Review nicht durch die Person erfolgt, die den Code entwickelt hat, sondern durch jemand anderen. Weiters gibt es die Möglichkeit, ein sogenanntes Peer Review durchzuführen. Bei diesem führen die Person, die den Code entwickelt hat und eine zweite Person das Review durch und besprechen den vorliegenden Code. An dieser Stelle sollte das Prinzip des \textit{Pair Programming} \cite{Pair2016}, das aus dem \textit{Extreme Programming} \cite{Beck2005} kommt, erwähnt werden. Beim \textit{Pair Programming} arbeiten bei der Erstellung des Quellcodes jeweils zwei ProgrammiererInnen an einem Rechner. Dabei schreibt ein Programmierer/eine Programmiererin den Code und der/die zweite überlegt sich die Problemstellung, kontrolliert den geschriebenen Quellcode und spricht Probleme, welche dabei auffallen, sofort an. Bei \textit{Extreme Programming} geht es darum, dass formalisiertes Vorgehen in den Hintergrund gerückt wird und in erster Linie das Lösen einer Programmieraufgabe betrachtet wird. 

\section{Woher kommt CCD?}
Wie zahlreiche Ideen in der Softwareentwicklung gibt es auch die Idee des CCD seit vielen Jahren. Alle der im Abschnitt \ref{cha:WhatIsCleanCode} erwähnten Programmierer sind schon seit sehr vielen Jahren mit dem Programmieren von Code beschäftigt und haben sich dabei Regeln zu Grunde gelegt, wie sie Code möglichst wartbar, gut lesbar und wiederverwendbar gestalten können. CCD ist keine neue Idee, es ist eher eine Zusammenfassung vieler Regeln, welche sich in den letzten Jahren etabliert haben, um Software besser zu gestalten.

\SuperPar Eine Vorgehensweise, welche sich sehr stark damit beschäftigt Code so zu gestalten, dass er besser wiederverwendbar ist, ist die Verwendung von Design Patterns. Dazu gibt es das von der \textit{Gang of Four} geschrieben Buch Design Patterns- Elements of Reusable Object-Oriented Software \cite{Gamma1995}. Dieses Buch beschreibt zahlreiche Möglichkeiten, wie verschiedene Design Patterns in objektorientierten Programmiersprachen angewandt werden können, um den Code besser zu strukturieren. Dabei trägt die korrekte Verwendung dieser zu einer verbesserten Lesbarkeit des Codes bei. Wenn eines dieser Design Patterns im Code verwendet wird und die Klasse, welche dieses Design Pattern implementiert korrekt benannt ist, kann man bereits durch den Namen dieser Klasse darauf schließen, wie sie funktionieren wird. Ein Beispiel hierfür wäre das Singleton. Ein Singleton übernimmt dabei die Aufgabe, der Erzeugung und Verwaltung der einzigen Instanz einer Klasse. Es kapselt dabei den Zugriff in einem globalen Gültigkeitsbereich über eine Methode \textit{getInstance()}. Der Leser der Klasse, welche dieses Singleton implementiert, kann durch eine korrekte Benennung und das Vorhandensein der \textit{getInstance()} - Methode sofort darauf schließen, dass es sich dabei um ein Singleton handelt. Diese Eigenschaft von Design Patterns führt wie erwähnt dazu, dass der Code leichter zu lesen und einfacher zu verstehen ist. Voraussetzung dafür ist natürlich, dass die Design Patterns korrekt implementiert sind, ansonsten wäre die Grundvoraussetzung - der Code sollte genau so funktionieren, wie man es erwartet - nicht erfüllt. Wichtig bei der Unterscheidung zwischen Clean Code und Design Patterns ist die Tatsache, dass sich Design Patterns auf der Entwurfsebene befinden, Clean Code sich jedoch auf der Implementierungsebene befindet.

\SuperPar Ein weiteres Buch, welches man als Vorgänger von CCD bezeichnen könnte ist \textit{Agile Software Development. Principles, Patterns, and Practices} \cite{Martin2002} von Robert C. Martin. In diesem Buch beschreibt er sehr zentrale Prinzipien in der modernen Softwareentwicklung. Im Folgenden werden die wichtigsten dieser Prinzipien, welche heutzutage auch kurz als SOLID - Prinzipien bezeichnet werden, kurz beschrieben und ihr Vorteil hinsichtlich CCD erwähnt. Für die einzelnen Prinzipien gibt es meist verschiedene Definitionen. Im Folgenden werden jedoch die originalen Definitionen von Robert C. Martin verwendet, welche er unter \cite{Martin2016} publiziert hat. 

\subsubsection{Single-Responsibility-Prinzip (SRP)}
\begin{quotation}
	A class should have one, and only one, reason to change.
\end{quotation}

Mit dem SRP werden sehr viele grundlegende Aspekte von CCD abgedeckt. Klassen, welche nur einen Zweck erfüllen und daher nur einen Grund haben sich zu ändern, sind leichter zu warten und zu lesen, da sich der/die Programmierer/Programmiererin auf die eine Aufgabe konzentrieren kann, welche diese Klasse erfüllt. Weiters wird das Testen dieser Klasse aus den selben Gründen vereinfacht. 

\subsubsection{The Open Closed Principle (OCP)}
\begin{quotation}
	You should be able to extend a classes behavior, without modifying it.
\end{quotation}

Beim OCP geht es in erster Linie darum, Klassen so zu gestalten, dass sie geschlossen für Änderungen und offen für Erweiterungen sind. 
Daraus ergibt sich, dass das Hinzufügen von neuen Funktionalitäten leichter wird, da bei Einhaltung dieses Prinzips keine Änderung der bestehenden Logik nötig ist. Diese kann ohne weiteres gleich wie vorher verwendet werden und die neue Funktionalität wird nur als Erweiterung angeboten. Das Einhalten dieses Prinzips führt automatisch zu besser strukturierten und gekapselten Klassen und schlussendlich auch zu einer leichteren Erfüllung des SRP.

\subsubsection{The Liskov Substitution Principle (LSP)}
\begin{quotation}
	Derived classes must be substitutable for their base classes.
\end{quotation}

Bei einer korrekten Anwendung des LSP sollte Klassen so gestaltet sein, dass bei jeder Verwendung des Objektes einer Oberklasse, dieses Objekt durch ein Objekt einer abgeleiteten Klasse ersetzt werden kann und dadurch kein fehlerhaftes Verhalten hervorgerufen wird. Der Vorteil der sich bei Einhaltung dieses Prinzips ergibt ist, dass bei Aufruf einer Methode einer abgeleiteten Klasse kein unerwartetes Verhalten hervorgerufen wird. Grundlegend lässt sich sagen, dass Verhalten, welches definiert ist, auch implementiert sein sollte.  

\subsubsection{The Interface Segregation Principle (ISP)}
\begin{quotation}
	Make fine grained interfaces that are client specific.
\end{quotation}

Durch feingranular definierte Interfaces wird der von Dave Thomas erwähnte Punkt von klaren und minimalen APIs erfüllt. Sehr minimal definierte Interfaces erfüllen außerdem das SRP und sind durch diese Granularität leichter zu verwenden. Ein weiterer positiver Aspekt von Interfaces, welche das ISP erfüllen, ist die leichtere Implementierung dieser.

\subsubsection{The Dependency Inversion Principle(DIP)}
\begin{quotation}
	Depend on abstractions, not on concretions.
\end{quotation}

Zwei Dinge, welche durch DIP ermöglicht werden, sind die bessere Testbarkeit, da man die konkrete Implementierung durch eine Testimplementierung mit Dummydaten ersetzen kann und die Tatsache, dass die Grenzen zwischen den einzelnen Softwaresystemen besser abgetrennt sind. Weiters ergibt sich dadurch der Vorteil, dass bei Komponenten, welche noch nicht zur Verfügung stehen, eine Dummyimplementierung verwendet werden kann. 