\section{Legacy Code}

\SuperPar Sehr oft kommt es in der Softwareentwicklung zu einer sehr komplexen Struktur der einzelnen Komponenten. Klassen mit sehr vielen Funktionen. Funktionen, welche mehr als eine Aufgabe erfüllen und daher oft sehr lange werden. Nicht mehr benötigte Codeabschnitte, welche aus Angst vor einem Verlust dieser nicht gelöscht werden. Dies sind nur einige der Probleme, welche in der Softwareentwicklung auftreten können. Viele dieser Probleme sind leicht zu lösen. Durch moderne Versionsverwaltungssysteme ist es nicht mehr nötig Codeabschnitte, die nicht mehr benötigt werden auszukommentieren. Diese können einfach gelöscht werden. Einige Probleme, welche sich zum Beispiel bei Klassen mit sehr vielen Methoden ergeben, können nur durch Erfahrung und Übung erkannt werden. Es sollte bei Klassen und Funktionen vor allem darauf geachtet werden, dass diese nur genau einen Zweck erfüllen. Ein weiterer wichtiger Indikator, ob eine Komponente gut programmiert ist, ist die Testbarkeit dieser. Bei schlecht programmierten beziehungsweise geplante Klassen ist es nur sehr schwer - oder gar nicht - möglich diese zu Testen. Im folgenden Abschnitt werden die häufigsten Probleme für komplexe Strukturen beziehungsweise schwer zu verstehende Konstrukte aufgearbeitet.

\subsection{Auskommentierter Code}
\begin{itemize}
	\item Projekt: \textit{Hibernate}
	\item Programmiersprache: \textit{Java}
	\item Betreffende Klasse: \textit{BindHelper}
	\item Betreffendes Paket: \textit{org.hibernate.cfg}
\end{itemize}


\SuperPar Code der nicht mehr benötigt wird, wird häufig einfach auskommentiert und bleibt danach über lange Zeit im Quellcode bestehen. Dies wäre jedoch bei den modernen Versionsverwaltungssystemen gar nicht mehr notwendig, da diese eine genaue Auflistung der gelöschten, geänderten oder hinzugefügten Abschnitte anbieten. Es ist mit diesen auch leicht möglich Abschnitte, die man gelöscht hat, wieder aufzufinden, sowie diese wiederherzustellen. Code der nicht mehr benötigt wird sollte daher einfach gelöscht werden und mit einer vernünftigen Commit Message versehen werden. Im Hibernate Framework ist eine Klasse die einen solchen auskommentierten Codeabschnitt enthält die \textit{BindHelper} Klasse. Eine sehr problematische Stelle befindet sich in dieser Klasse in Zeile 421. Dort gibt es den in Listing \ref{lst:CommentedCode} beschriebenen Codeabschnitt.

\begin{lstlisting}[language=Java, caption=Beispiele für auskommentierten Code, label=lst:CommentedCode]
/*FIXME cannot use subproperties becasue the caller needs top level properties
//if (property.isComposite()) {
//	Iterator subProperties = ((Component)property.getValue()).getPropertyIterator();
// 	while (subProperties.hasNext()) {
//  	matchColumnsByProperty(((Property)subProperties.next()), columnsToProperty);
// 	}
}*/ 
\end{lstlisting}

\SuperPar Der Kommentar deutet darauf hin, dass es in diesem Codeabschnitt einen Fehler gibt der behoben werden müsste. Anstatt diesen Fehler zu beheben wurde der Code einfach auskommentiert und nach einigen Wochen weiß niemand mehr, dass es diesen Fehler gibt. Hier sollte entweder in einem Issue Tracking System genau mitdokumentiert werden, wo der Fehler auftritt und Möglichkeiten diesen zu beheben, oder den Fehler direkt zu beheben. Diesen einfach stehen zu lassen und die fehlerhafte Codestelle auszukommentieren ist dabei wohl der schlechteste Weg, da so der Fehler nicht mehr auftreten wird und er somit vergessen wird, wodurch sich vermutlich weitere Probleme ergeben. Auch Robert C. Martin schlägt in seinem Buch eine sehr pragmatische Lösung vor: Auskommentierter Code sollte immer gelöscht werden, da er zusätzlich zu den genannten Gründen auch den Quellcode unnötig aufbläht.

\subsection{Rückgabe von Fehlercodes}

\SuperPar In den modernen Programmiersprachen wie C++, C\# oder Java, gibt es die Möglichkeit, für einen fehlgeschlagenen Vorgang eine Ausnahme zu werfen. In den etwas älteren Programmiersprachen, wie zum Beispiel C, gab es diese Möglichkeit noch nicht. Daher wurden in solchen Situationen sogenannte Fehlercodes zurückgegeben, was dazu führte, dies führte zu mehreren Problemen: 

\begin{itemize}
	\item Beim Aufruf dieser Methode muss darauf geachtet werden, dass alle möglichen Fehlercodes abgedeckt werden. 
	\item Da diese Fehlercodes meist ganzzahlige Werte darstellen, ist es auch sehr schwierig, diesen eine gewisse Semantik zuordnen. Meist werden für diese ganzzahligen Werte dann Konstanten definiert, welche dann im Quelltext, oder der Dokumentation beschrieben werden. 
	\item Durch die Rückgabe eines Fehlercodes ist es nicht mehr möglich einen Wert zurückzugegeben, wodurch meist Parameter als Outputparameter verwendet werden, welche den gewünschten Wert zurückliefern.
\end{itemize}

\SuperPar In den modernen Programmiersprachen gibt es wie bereits beschrieben die Möglichkeit von Ausnahmen. Diese Ausnahmen werden dabei im Fehlerfall ausgelöst und schließlich im aufrufenden Bereich behandelt. Diesen Ausnahmen kann eine Fehlermeldung zugeordnet werden und es gibt die Möglichkeit über den sogenannten Stacktrace nachzuvollziehen, an welcher Stelle im Code der Fehler aufgetreten. Weiters ist es durch dieses System ohne weiters Möglich bei der Funktion einen normalen Rückgabewert zu definieren, da die Ausnahme nicht als Rückgabewert definiert werden muss. Durch diese Möglichkeiten ergeben sich zahlreiche Vorteile gegenüber Fehlercodes und daher sollte bei Verwendung von moderneren Programmiersprachen auf Fehlercodes unbedingt verzichtet werden.

\subsection{Switch Statements}
\begin{itemize}
	\item Projekt: \textit{Entity Framework}
	\item Programmiersprache: \textit{C\#}
	\item Betreffende Klasse: \textit{CommandLogger }
	\item Betreffender Namespace: \textit{Microsoft.Data.Entity.Design.Internal}
\end{itemize}

\SuperPar Ein Konstrukt das sich in sehr vielen Bibliotheken finden lässt sind \textit{Switch-Statements}. Über diese wird meist geregelt, welche Aktionen abhängig von einer Eingabe durchgeführt werden. Dies führt zu einer Vermischung der Aspekte. Die Funktion, welche diese Überprüfungen vornimmt hat dadurch mindestens zwei Aufgaben. Einerseits wird die Eingabe überprüft und abhängig davon eine Aktion vorgenommen. Dies führt im Weiteren auch zu einer schlechteren Testbarkeit. In objektorientierten Programmiersprachen können die meisten \textit{Switch-Statements} durch einfache Abstrahierungen ersetzt werden. Ein gutes Beispiel, wo diese Verbesserung angewandt werden könnte wird in Listing \ref{lst:SwitchStatement} gezeigt.

\begin{lstlisting}[language={[Sharp]C}, caption=Beispiele für Switch Statement; label=lst:SwitchStatement]
public virtual void Log(
	LogLevel logLevel,
	int eventId,
	object state,
	Exception exception,
	Func<object, Exception, string> formatter)
{
	//Building message
	...
	//

	switch (logLevel)
	{
		case LogLevel.Error:
			WriteError(message.ToString());
			break;
		case LogLevel.Warning:
			WriteWarning(message.ToString());
			break;
		case LogLevel.Information:
			WriteInformation(message.ToString());
			break;
		case LogLevel.Debug:
			WriteDebug(message.ToString());
			break;
		case LogLevel.Trace:
			WriteTrace(message.ToString());
			break;
		default:
			Debug.Fail("Unexpected event type: " + logLevel);
			WriteDebug(message.ToString());
			break;
	}
}
\end{lstlisting}

\SuperPar Hier wird überpüft, welches \textit{LogLevel} übergeben wird und anschließend wird die jeweilige Methode aufgerufen. Hier wäre es jedoch einfach möglich, statt dem \textit{LogLevel}  ein Objekt zu übergeben, welches das in Listing \ref{lst:LogInterface} dargestellte Interface implementiert.

\begin{lstlisting}[language={[Sharp]C}, caption=Beispiele für ein Log Interface, label=lst:LogInterface]
public interface ILogger
{
	void WriteLog(string message);
}
\end{lstlisting}

\SuperPar Dadurch, dass es jetzt möglich ist, die Methode WriteLog des übergebene Objektes aufzurufen ergibt sich der in Listing \ref{lst:WithoutSwitch} dargestellte Quellcode.

\begin{lstlisting}[language={[Sharp]C}, caption=Beispiele für Switch Statement; label=lst:SwitchStatement]
public virtual void Log(
	ILogger logger,
	int eventId,
	object state,
	Exception exception,
	Func<object, Exception, string> formatter)
{
	//Building message
	...
	//

	logger.WriteLog(message.ToString());
}
\end{lstlisting}

\SuperPar Durch diese Änderung wird die Funktion um einiges kürzer und dadurch übersichtlicher. Es wird außerdem dadurch die Aufgabe der Überprüfung ausgelagert. Beim Aufrufen dieser Methode kann jetzt zusätzlich zu den bekannten \textit{LogLevels} auch ein spezieller Logger übergeben werden, welcher zum Beispiel in eine Datenbank schreibt. Die wichtigste Verbesserung ist hier, wie bereits erwähnt, die stark verbesserte Lesbarkeit. 


\subsection{Rückgabe von Null}
\begin{itemize}
	\item Projekt: \textit{CoreFx}
	\item Programmiersprache: \textit{C\#}
	\item Betreffende Klasse: \textit{ProcessModuleCollection}
	\item Betreffender Namespace: \textit{System.Diagnostics}
\end{itemize}

\SuperPar In modernen Programmierumgebungen wie Java und C\# stellen die sogenannten \textit{Nullreferenzausnahmen} eine der häufigsten Ausnahmefälle dar. Diese führen dazu, dass beim Zugriff auf ein Objekt, welches den Wert \textit{null} besitzt, ein Laufzeitfehler auftritt, welcher behandelt werden muss. Noch problematischer sind diese Ausnahmen im C++ - Bereich, da dort keine Ausnahme ausgelöst wird, falls das Objekt den Wert null besitzt, da jedes Objekt auf einen gewissen Speicherbereich verweist und dieser Speicherbereich aber vorhanden ist. In C++ führt der Zugriff auf ein \textit{Null-Objekt} zu einem Zugriff auf einen ungültigen Speicherbereich. Solche Fehler sind sehr schwer nachzuvollziehen und führen häufig zu großen Problemen wenn die Software bereits im Betrieb ist. Meist wird diesen Problem durch zahlreiche Überprüfungen ob der zurückgegebene Wert \textit{null} ist, vorgebeugt. Dies führt aber zu stark überladenen Methoden und kann es kann auch sehr schnell darauf vergessen werden diese Überprüfungen einzubauen.

\SuperPar Diese Probleme und die Überladung des Codes mit Überprüfungen können durch das Verzichten auf die Rückgabe von Null Werten verhindert werden. Für Enumerationstypen wie Listen oder ähnlichem sollte eine leere Liste zurückgegeben werden. Meist wird für Listen nach dem Aufruf eine Form der Iteration durchgeführt. Entweder wird in einer \textit{for-Schleife} über die einzelnen Elemente der Liste iteriert, was bei einer leeren Liste einfach dazu führt, dass die Schleife nicht durchlaufen wird. Bei Objekten gibt es die Möglichkeit das sogenannte \textit{Nullobjectpattern} zu verwenden. Bei diesem Pattern wird statt des Wertes \textit{null} eine leere Implementierung des Objektes zurückgegeben. Ein Beispiel, wo ein solches \textit{Nullobjectpattern} Anwendung finden könnte wäre der Codeabschnitt in Listing \ref{lst:ReturnZero}. 

\begin{lstlisting}[language={[Sharp]C}, caption=Beispiele für Rückgabe eines Null Wertes, label=lst:ReturnZero]
protected List<ProcessModule> InnerList
{
	get
	{
			if (_list == null)
				_list = new List<ProcessModule>();
		return _list;
	}
}
\end{lstlisting}

\SuperPar Hier wird zu erst intern überprüft, ob die Liste, welche in einer Membervariable gespeichert ist \textit{null} ist, wenn ja wird der Wert dieser auf eine leere Liste gesetzt und somit können \textit{Nullreferenzausnahmen} verhindert werden. 


