\section{Komplexe Strukturen und schwer zu verstehende Konstrukte}

\SuperPar Sehr oft kommt es in der Softwareentwicklung zu einer sehr komplexen Struktur der einzelnen Komponenten. Klassen mit sehr vielen Funktionen. Funktionen, welche mehr als eine Aufgabe erfüllen und daher oft sehr lange werden. Nicht mehr benötigte Codeabschnitte, welche aus Angst vor einem Verlust dieser nicht gelöscht werden. Dies sind nur einige der Probleme, welche in der Softwareentwicklung auftreten können. Viele dieser Probleme sind leicht zu lösen. Durch moderne Versionsverwaltungssysteme ist es nicht mehr nötig Codeabschnitte, die nicht mehr benötigt werden auszukommentieren. Diese können einfach gelöscht werden. Einige Probleme, welche sich zum Beispiel bei Klassen mit sehr vielen Methoden ergeben, können nur durch Erfahrung und Übung erkannt werden. Es sollte bei Klassen und Funktionen vor allem darauf geachtet werden, dass diese nur genau einen Zweck erfüllen. Ein weiterer wichtiger Indikator, ob eine Komponente gut programmiert ist, ist die Testbarkeit dieser. Bei schlecht programmierten beziehungsweise geplante Klassen ist es nur sehr schwer - oder gar nicht - möglich diese zu Testen. Im folgenden Abschnitt werden die häufigsten Probleme für komplexe Strukturen beziehungsweise schwer zu verstehende Konstrukte aufgearbeitet.

\subsection{Auskommentierter Code}
\begin{itemize}
	\item Projekt: \textit{Hibernate}
	\item Programmiersprache: \textit{Java}
	\item Betreffende Klasse: \textit{BindHelper}
	\item Betreffendes Paket: \textit{org.hibernate.cfg}
\end{itemize}


\SuperPar Code der nicht mehr benötigt wird, wird häufig einfach auskommentiert und bleibt danach über lange Zeit im Quellcode bestehen. Dies wäre jedoch bei den modernen Versionsverwaltungssystemen gar nicht mehr notwendig, da diese eine genaue Auflistung der gelöschten, geänderten oder hinzugefügten Abschnitte anbieten. Es ist mit diesen auch leicht möglich Abschnitte, die man gelöscht hat, wieder aufzufinden, sowie diese wiederherzustellen. Code der nicht mehr benötigt wird sollte daher einfach gelöscht werden und mit einer vernünftigen Commit Message versehen werden. Im Hibernate Framework ist eine Klasse die einen solchen auskommentierten Codeabschnitt enthält die \textit{BindHelper} Klasse. Eine sehr problematische Stelle befindet sich in dieser Klasse in Zeile 421. Dort gibt es den in Listing \ref{lst:CommentedCode} beschriebenen Codeabschnitt.

\begin{lstlisting}[language=Java, caption=Beispiele für auskommentierten Code, label=lst:CommentedCode]
/*FIXME cannot use subproperties becasue the caller needs top level properties
//if (property.isComposite()) {
//	Iterator subProperties = ((Component)property.getValue()).getPropertyIterator();
// 	while (subProperties.hasNext()) {
//  	matchColumnsByProperty(((Property)subProperties.next()), columnsToProperty);
// 	}
}*/ 
\end{lstlisting}

\SuperPar Der Kommentar deutet darauf hin, dass es in diesem Codeabschnitt einen Fehler gibt der behoben werden müsste. Anstatt diesen Fehler zu beheben wurde der Code einfach auskommentiert und nach einigen Wochen weiß niemand mehr, dass es diesen Fehler gibt. Hier sollte entweder in einem Issue Tracking System genau mitdokumentiert werden, wo der Fehler auftritt und Möglichkeiten diesen zu beheben, oder den Fehler direkt zu beheben. Diesen einfach stehen zu lassen und die fehlerhafte Codestelle auszukommentieren ist dabei wohl der schlechteste Weg, da so der Fehler nicht mehr auftreten wird und er somit vergessen wird, wodurch sich vermutlich weitere Probleme ergeben. Auch Robert C. Martin schlägt in seinem Buch eine sehr pragmatische Lösung vor: Auskommentierter Code sollte immer gelöscht werden, da er zusätzlich zu den genannten Gründen auch den Quellcode unnötig aufbläht.

\subsection{Kapseln von Errorhandling in eigene Methoden}
\begin{itemize}
	\item Projekt: \textit{Roslyn}
	\item Programmiersprache: \textit{C\#}
	\item Betreffende Klasse: \textit{MetadataAndSymbolCache}, \textit{FileKey}
	\item Betreffender Namespace: \textit{Microsoft.CodeAnalysis.CompilerServer}, \textit{Roslyn.Utilities}
\end{itemize}

\SuperPar Das behandeln von Fehlern und Ausnahmen ist ein sehr zentraler Aspekt eines jeden Programmes. Eine richige und gut implementierte Strategie zur Fehlerbehandlung kann sehr viel Einfluss auf die Wartbarkeit eines Programmes haben. Oft wird dabei Logik und Fehlerbehandlung vermischt, was meist zu einer Verschlechterung der Lesbarkeit führt. Da es bei der Fehlerbehandlung um einen eigenen Aspekt geht, sollte diese in eine eigene Methode ausgelagert werden. Diese Methode ist dabei ein Wrapper für die zu behandelte Methode. Ein Beispiel aus dem Quelltext von Roslyn ist die in Listing \ref{lst:AspectedErrorhandling1} gezeigte Methode.

\begin{lstlisting}[language={[Sharp]C}, caption=Beispiele für getrennten Aspket der Fehlerbehandlung, label=lst:AspectedErrorhandling1]
private FileKey? GetUniqueFileKey(string filePath)
{
	try
	{
		return FileKey.Create(filePath);
	}
	catch (Exception)
	{
		// There are several exceptions that can occur 
		// here: NotSupportedException or 
		// PathTooLongException
		// for a bad path, UnauthorizedAccessException 
		// for access denied, etc. Rather than listing
		// them all, just catch all exceptions.
		return null;
	}
}
\end{lstlisting}

\SuperPar Um sich auf den wesentlichen Punkt in diesem Abschnitt, die Fehlerbehandlung, zu konzentrieren, wird der redundante Kommentar und die Rückgabe eines null-Wertes ignoriert. Dies sollte in einem anderen Abschnitt näher behandelt werden. % TOODOO ADD Null value return descripton %
Was man an diesem Beispiel gut erkennen kann, ist die Trennung der Aspekte. Es wird eine Methode zum Erstellen eines \textit{FileKey} Objektes aufgerufen. Anstatt die Fehlerbehandlung in der \textit{Create} Methode zu erledigen, wird sie außerhalb dieser Methode implementiert und führt daher zu keiner Vermischung der Aspekte. Dabei ergibt sich ein weiters Problem. Beim Aufruf der Methode \textit{Create} kann auf die Fehlerbehandlung vergessen werden, was im schlimmsten Fall zu einer unbehandelten Ausnahme führt. Es wäre daher vernünftiger die Fehlerbehandlung direkt in einen Wrapper in der Klasse \textit{FileKey} zu implementieren, der die Fehlerbehandlung vornimmt und danach die Methode \textit{Create} aufruft.

\SuperPar Dies würde in den in Listing \ref{lst:AspectedErrorhandling2} und in Listing \ref{lst:AspectedErrorhandling3} gezeigten Änderung in der Klasse \textit{FileKey} resultieren.

\begin{lstlisting}[language={[Sharp]C}, caption=Fehlerbehandlung in der Klasse FileKey vorher, label=lst:AspectedErrorhandling2]
public static FileKey Create(string fullPath)
{
	return new FileKey(fullPath, FileUtilities.GetFileTimeStamp(fullPath));
}
\end{lstlisting}

\begin{lstlisting}[language={[Sharp]C}, caption=Fehlerbehandlung in der Klasse FileKey nachher, label=lst:AspectedErrorhandling3]
private static FileKey CreateKey(string fullPath)
{
	return new FileKey(fullPath, FileUtilities.GetFileTimeStamp(fullPath));
}
				
public static FileKey? Create(string fullPath)
{
	try
	{
		return Create(filePath);
	}
	catch (Exception)
	{
		return null;
	}
}
\end{lstlisting}

\SuperPar Der Aufruf würde der gleiche bleiben, da nur die \textit{Create} Methode im öffentlichen Gültigkeitsbereich zugänglich ist, jedoch könnte sichergestellt werden, dass eine Fehlerbehandlung stattfindet. Auf Grund der Tatsache, dass im Fehlerfall \textit{null} zurückgegeben werden sollte, gibt es eine kleine Änderungen an der Signatur, sodass mit dieser Variante ein \textit{FileKey?} zurückgegeben wird, was einem Strukturdatentyp entspricht der den Wert null annehmen kann. 

\subsection{Rückgabe von Fehlercodes}

\SuperPar In den modernen Programmiersprachen wie C++, C\# oder Java, gibt es die Möglichkeit, für einen fehlgeschlagenen Vorgang eine Ausnahme zu werfen. In den etwas älteren Programmiersprachen, wie zum Beispiel C, gab es diese Möglichkeit noch nicht. Daher wurden in solchen Situationen sogenannte Fehlercodes zurückgegeben, was dazu führte, dies führte zu mehreren Problemen: 

\begin{itemize}
	\item Beim Aufruf dieser Methode muss darauf geachtet werden, dass alle möglichen Fehlercodes abgedeckt werden. 
	\item Da diese Fehlercodes meist ganzzahlige Werte darstellen, ist es auch sehr schwierig, diesen eine gewisse Semantik zuordnen. Meist werden für diese ganzzahligen Werte dann Konstanten definiert, welche dann im Quelltext, oder der Dokumentation beschrieben werden. 
	\item Durch die Rückgabe eines Fehlercodes ist es nicht mehr möglich einen Wert zurückzugegeben, wodurch meist Parameter als Outputparameter verwendet werden, welche den gewünschten Wert zurückliefern.
\end{itemize}

\SuperPar In den modernen Programmiersprachen gibt es wie bereits beschrieben die Möglichkeit von Ausnahmen. Diese Ausnahmen werden dabei im Fehlerfall ausgelöst und schließlich im aufrufenden Bereich behandelt. Diesen Ausnahmen kann eine Fehlermeldung zugeordnet werden und es gibt die Möglichkeit über den sogenannten Stacktrace nachzuvollziehen, an welcher Stelle im Code der Fehler aufgetreten. Weiters ist es durch dieses System ohne weiters Möglich bei der Funktion einen normalen Rückgabewert zu definieren, da die Ausnahme nicht als Rückgabewert definiert werden muss. Durch diese Möglichkeiten ergeben sich zahlreiche Vorteile gegenüber Fehlercodes und daher sollte bei Verwendung von moderneren Programmiersprachen auf Fehlercodes unbedingt verzichtet werden.

\subsection{Switch Statements}
\begin{itemize}
	\item Projekt: \textit{Entity Framework}
	\item Programmiersprache: \textit{C\#}
	\item Betreffende Klasse: \textit{CommandLogger }
	\item Betreffender Namespace: \textit{Microsoft.Data.Entity.Design.Internal}
\end{itemize}

\SuperPar Ein Konstrukt das sich in sehr vielen Bibliotheken finden lässt sind \textit{Switch-Statements}. Über diese wird meist geregelt, welche Aktionen abhängig von einer Eingabe durchgeführt werden. Dies führt zu einer Vermischung der Aspekte. Die Funktion, welche diese Überprüfungen vornimmt hat dadurch mindestens zwei Aufgaben. Einerseits wird die Eingabe überprüft und abhängig davon eine Aktion vorgenommen. Dies führt im Weiteren auch zu einer schlechteren Testbarkeit. In objektorientierten Programmiersprachen können die meisten \textit{Switch-Statements} durch einfache Abstrahierungen ersetzt werden. Ein gutes Beispiel, wo diese Verbesserung angewandt werden könnte wird in Listing \ref{lst:SwitchStatement} gezeigt.

\begin{lstlisting}[language={[Sharp]C}, caption=Beispiele für Switch Statement; label=lst:SwitchStatement]
public virtual void Log(
	LogLevel logLevel,
	int eventId,
	object state,
	Exception exception,
	Func<object, Exception, string> formatter)
{
	//Building message
	...
	//

	switch (logLevel)
	{
		case LogLevel.Error:
			WriteError(message.ToString());
			break;
		case LogLevel.Warning:
			WriteWarning(message.ToString());
			break;
		case LogLevel.Information:
			WriteInformation(message.ToString());
			break;
		case LogLevel.Debug:
			WriteDebug(message.ToString());
			break;
		case LogLevel.Trace:
			WriteTrace(message.ToString());
			break;
		default:
			Debug.Fail("Unexpected event type: " + logLevel);
			WriteDebug(message.ToString());
			break;
	}
}
\end{lstlisting}

\SuperPar Hier wird überpüft, welches \textit{LogLevel} übergeben wird und anschließend wird die jeweilige Methode aufgerufen. Hier wäre es jedoch einfach möglich, statt dem \textit{LogLevel}  ein Objekt zu übergeben, welches das in Listing \ref{lst:LogInterface} dargestellte Interface implementiert.

\begin{lstlisting}[language={[Sharp]C}, caption=Beispiele für ein Log Interface, label=lst:LogInterface]
public interface ILogger
{
	void WriteLog(string message);
}
\end{lstlisting}

\SuperPar Dadurch, dass es jetzt möglich ist, die Methode WriteLog des übergebene Objektes aufzurufen ergibt sich der in Listing \ref{lst:WithoutSwitch} dargestellte Quellcode.

\begin{lstlisting}[language={[Sharp]C}, caption=Beispiele für Switch Statement; label=lst:SwitchStatement]
public virtual void Log(
	ILogger logger,
	int eventId,
	object state,
	Exception exception,
	Func<object, Exception, string> formatter)
{
	//Building message
	...
	//

	logger.WriteLog(message.ToString());
}
\end{lstlisting}

\SuperPar Durch diese Änderung wird die Funktion um einiges kürzer und dadurch übersichtlicher. Es wird außerdem dadurch die Aufgabe der Überprüfung ausgelagert. Beim Aufrufen dieser Methode kann jetzt zusätzlich zu den bekannten \textit{LogLevels} auch ein spezieller Logger übergeben werden, welcher zum Beispiel in eine Datenbank schreibt. Die wichtigste Verbesserung ist hier, wie bereits erwähnt, die stark verbesserte Lesbarkeit. 

