\chapter{Einleitung}
\label{cha:Einleitung}

\section{Problemstellung}
\label{cha:Problemstellung}
Ein sehr zentraler Aspekt der Softwareentwicklung ist die Notwendigkeit, Software ständig zu ändern. Dies kann aus verschiedenen Gründen nötig werden. Ein Kunde möchte ein neues Feature implementiert haben, bei einem anderen Kunden ist ein Fehler aufgetreten der behoben werden sollte. Ein weiterer Kunde beschwert sich über die sehr schlechte Performance einer Funktionalität. Alle diese Fälle haben eines gemeinsam; sie erfordern eine Änderung der bestehenden Software. Die Gesetze, warum sich Software ändert, wurden von Manny Lehman \cite{Lehman1980} bereits hinlänglich beschrieben. 

Wenn man in der glücklichen Lage ist ein neues Produkt zu entwickeln ist es oft noch sehr leicht weitere Funktionalität hinzuzufügen, aber Neuentwicklungen, sogenannte \textit{ Greenfield Applications} sind sehr selten der Fall. Meistens muss die Funktionalität zu einer bereits vorhandenen, meist schon länger entwickelten, Codebasis hinzugefügt werden. In vielen Fällen kommen jetzt zahlreiche Probleme zum Tragen: Es wurde beim ersten Entwurf der Software nicht daran gedacht, dass diese Feature benötigt wird, daher ist es durch die gewählte Architektur nur sehr schwer möglich die gewünschte Funktionalität hinzuzufügen. Dies kann wiederum dazu führen, dass versucht wird einen Workaround zu finden, sodass die Funktionalität trotzdem realisiert werden kann, jedoch führt dies zu einer weiteren Verunstaltung des Quellcodes und er wird dadurch noch schwerer zu lesen und zu warten. 

Diese verschlechterte Lesbarkeit und Wartbarkeit führt dazu, dass Änderungen sehr viel Zeit benötigen und nur sehr selten vorgenommen werden. Im schlimmsten Fall ist irgendwann der Punkt erreicht, an dem die Software nicht mehr weiterentwickelt werden kann, da jede Änderung unvorhersehbare Seiteneffekte haben könnte. Dies führt schlussendlich wohl oder übel zum Tod der Software, den Software die sich nicht weiterentwickeln lässt wird früher oder später von besserer Software abgelöst. Dieses Problem wird auch als \textit{Legacy Code Problem} bezeichnet und ist hinlänglich bekannt und von vielen Autoren beschrieben z.B. Michael Feathers \cite{Feathers2013}.

\SuperPar Die ständige Verschlechterung der Codequalität lässt sich außerdem durch die von James Q. Wilson und George L.Kelling \cite{Wilson2016}  aufgestellte Theorie der zerbrochenen Fenster erklären. Bei dieser Theorie geht es darum, welche Folgen ein zerbrochenes Fenster in einem Gebäude nach sich zieht insofern dieses nicht repariert wird. Die Autoren erläutern dabei, dass durch die Tatsache, dass es aussieht als ob sich niemand um den Zustand dieses Gebäudes kümmern würde, weitere Zerstörung nach sich ziehen wird. Robert C. Martin (\cite{Martin2008}) verwendet diese Theorie und bringt sie in Verbindung mit der Softwareentwicklung. Dabei beschreibt er einen sehr ähnlichen Fall wie der eines zerbrochenen Fensters. Bei einem Programmabschnitt, sei es eine Klasse, eine Methode oder ähnliches, die bereits unsauber programmiert und schlecht lesbar ist, wird bei zukünftigen Änderungen auch nicht darauf geachtet werden den Code sauber zu gestalten. Es werden immer mehr unsaubere Codeteile hinzugefügt, was schlussendlich von unsauberen Code zu nicht mehr wartbarem Code führen kann. Dieses Problem existiert in allen Teilen der Programmierung. Bei Projekten, bei denen nicht auf einen sauber gestalteten Code geachtet wurde, wird in Zukunft auch nur selten darauf geachtet. 

\section{Lösungsvorschlag}
Um diese Probleme zu vermeiden, sollten Regeln und Grundsätze gefunden werden, wie gut lesbarer bzw. wartbarer Code gestaltet werden kann. Dabei ist es sehr wichtig darauf zu achten, dass der Code meist nicht nur von einer Person bearbeitet und gelesen wird, sondern von vielen verschiedenen Personen. Wenn darauf geachtet wird denn Code so zu gestalten, dass er verständlich, gut lesbar und gut strukturiert ist, dann ist es auch nach einigen Wochen, Monaten und Jahren noch gut möglich zu verstehen, was der Zweck der betrachteten Codestelle ist. In den letzten Jahren hat sich zu diesem Thema eine Strömung ergeben welche sich als Clean Code Development (im folgenden CCD) bezeichnet. Geprägt wurde diese Bewegung in erster Linie von Robert. C. Martin und seinem Buch Clean Code \cite{Martin2008}. Er beschreibt dabei, dass umso genauer beim Schreiben des Quellcodes darauf geachtet wurde, diesen lesbar zu gestalten, desto leichter wird es für zukünftige Leser des Quellcodes diesen zu verstehen und auch zu ändern. 

\section{Ziele}
Das Hauptziel der Arbeit besteht darin, zu zeigen, wie CCD dabei unterstützen kann, besseren Quellcode zu schreiben. Dem Leser sollte am Ende dieser Arbeit klar sein, dass CCD für alle Stakeholder eines Softwareprojektes Vorteile bietet. Für den Kunden ergibt sich der Vorteil, dass gewünschte Änderungen leichter eingearbeitet werden können, da durch die verbesserte Lesbarkeit und Struktur eine Änderung bzw. ein Hinzufügen von Funktionalitäten sehr stark erleichtert wird. Für das Unternehmen ergeben sich dadurch ähnliche Vorteile wie für den Kunden. Dadurch, dass es leichter ist Funktionalitäten hinzuzufügen, ist das Unternehmen wettbewerbsfähiger, da man Änderungen am Produkt oder Verbesserungen leichter einbauen kann. Für die ProgrammiererInnen wird die Arbeit durch Clean Code sehr stark vereinfacht, da durch die bessere Lesbarkeit ein Einarbeiten in den Quellcode um einiges leichter wird. Ein weiteres Ziel dieser Arbeit ist es zu zeigen, dass es selbst durch kleine Schritte möglich ist, eine enorme Verbesserung des Quellcodes zu erreichen. 

Die Arbeit ist in folgende Abschnitte gegliedert:
\begin{itemize}
	\item Abschnitt 1 beschäftigt sich in erster Linie mit allgemeinen Aspekten des CCD. Es wird in diesem Abschnitt geklärt, wofür Clean Code Development steht, was Clean Code bedeutet, welche Möglichkeiten es gibt Clean Code zu schreiben und zu überprüfen. Weiters wird auch kurz auf die Entstehung von Clean Code Development eingegangen und Tools und Möglichkeiten gezeigt, wie Clean Code Development in den Alltag einfließen kann.
	\item In Abschnitt 2 werden einige der in Abschnitt 1 beschriebenen Clean Code Kriterien beispielhaft angewandt. Diese Beispiele sind zu großen Teilen aus Open Source Frameworks und sollen zeigen, wie die Lesbarkeit durch wenige Änderungen im Quellcode verbessert werden kann. Dabei wird immer ein Ist-Stand gezeigt, welcher eines der Clean Code Kriterien missachtet. Danach sollte geklärt werden, welche Probleme dadurch entstehen können und schlussendlich wird gezeigt wie ein Clean Code Beispiel aussehen könnte und welche Vorteil diese bietet.
	\item Abschnitt 3 beschäftigt sich mit CCD im Alltag einer Firma und mit persönlichen Erfahrungen die im Zusammenhang mit CCD gemacht wurden. Dieser Abschnitt ist eine persönliche Einschätzung, wie wertvoll CCD für den alltäglichen Gebrauch ist.
\end{itemize}

