\chapter{Einleitung}
\label{cha:Einleitung}

\section{Problemstellung}
\label{cha:Problemstellung}
Ein sehr zentraler Aspekt der Softwareentwicklung ist die Tatsache, dass sich Software ständig ändert. Dies kann aus verschiedenen Gründen passieren. Ein Kunde möchte ein neues Feature implementiert haben, bei einem anderen Kunden ist ein Fehler aufgetreten der behoben werden sollte. Ein weiterer Kunde beschwert sich über die sehr schlechte Performance einer Funktionalität. Alle diese Fälle haben eines gemeinsam; sie erfordern eine Änderung der bestehenden Software. An dieser Stelle sollte auf die von Manny Lehman \cite{Lehman1980} in Form von Gesetzen beschrieben Gründe, warum sich Software ändert, verwiesen werden.

Wenn man in der glücklichen Lage ist ein neues Produkt zu entwickeln ist es oft noch sehr leicht weitere Funktionalität hinzuzufügen, aber Neuentwicklungen, sogenannte \textit{Greenfield Applications}, sind sehr selten der Fall. Meistens muss die Funktionalität zu einer bereits vorhandenen, meist schon länger entwickelten, Codebasis hinzugefügt werden. In vielen Fällen kommen dabei zahlreiche Probleme zum Tragen: 

Möglicherweise wurde beim Entwurf der Softwarearchitektur nicht auf die Erweiterbarkeit geachtet, wodurch es beim Hinzufügen von neuen Features zu großen Probleme kommen kann. Dies kann wiederum dazu führen, dass versucht wird einen Workaround zu finden, sodass die Funktionalität trotzdem realisiert werden kann. Dieser Workaround verschlechtert jedoch meistens die Lesbarkeit und die Wartbarkeit des Quellcodes.

Diese verschlechterte Lesbarkeit und Wartbarkeit führt dazu, dass Änderungen sehr viel Zeit benötigen und nur noch selten vorgenommen werden. Im schlimmsten Fall ist irgendwann der Punkt erreicht, an dem die Software nicht mehr weiterentwickelt werden kann, da jede Änderung unvorhersehbare Seiteneffekte haben könnte. Dies führt schlussendlich wohl oder übel zum Tod der Software, denn Software, die sich nicht weiterentwickeln lässt, wird früher oder später von besserer Software abgelöst. Dieses Problem wird auch als \textit{Legacy Code Problem} bezeichnet und ist hinlänglich bekannt und von vielen Autoren beschrieben z.B. von Michael Feathers \cite{Feathers2013}.

\SuperPar Die ständige Verschlechterung der Codequalität lässt sich außerdem durch die von James Q. Wilson und George L.Kelling \cite{Wilson2016}  aufgestellte Theorie der zerbrochenen Fenster erklären. Bei dieser Theorie geht es darum, welche Folgen ein zerbrochenes Fenster in einem Gebäude nach sich zieht, insofern dieses nicht repariert wird. Die Autoren erläutern dabei, dass dieses zerbrochene Fenster darauf schließen lässt, dass sich niemand um dieses Gebäude kümmert, was schlussendlich zu einer weiteren Zerstörung führen wird. Robert C. Martin (\cite{Martin2008}) verwendet diese Theorie und bringt sie in Verbindung mit der Entwicklung von Software. Dabei beschreibt er einen sehr ähnlichen Fall wie der eines zerbrochenen Fensters. Bei einem Programmabschnitt, sei es eine Klasse, eine Methode oder ähnliches, die bereits unsauber programmiert und schlecht lesbar ist, wird bei zukünftigen Änderungen auch nicht darauf geachtet werden, den Code sauber zu gestalten. Es werden immer mehr unsaubere Codeteile hinzugefügt, was schlussendlich von unsauberen Code, zu nicht mehr wartbarem Code führen kann. Bei Projekten, bei denen nicht auf einen sauber gestalteten Code geachtet wurde, ist davon auszugehen, dass in der Zukunft vermutlich auch nur selten darauf geachtet wird sauberen Code zu schreiben. 

\section{Lösungsvorschlag}
Um diese Probleme zu vermeiden, sollten Regeln und Grundsätze gefunden werden, wie gut lesbarer bzw. wartbarer Code gestaltet werden kann. Dabei ist es sehr wichtig darauf zu achten, dass der Code meist nicht nur von einer Person bearbeitet und gelesen wird, sondern von vielen verschiedenen Personen. Wenn darauf geachtet wird, den Code so zu gestalten, dass er verständlich, gut lesbar und gut strukturiert ist, dann ist es auch nach einigen Wochen, Monaten und Jahren noch gut möglich zu verstehen, was der Zweck der betrachteten Codestelle ist. In den letzten Jahren hat sich zu diesem Thema eine Strömung ergeben, welche sich als Clean Code Development (im folgenden CCD) bezeichnet. Geprägt wurde diese Bewegung in erster Linie von Robert. C. Martin und seinem Buch \textit{Clean Code} \cite{Martin2008}. 
In diesem Buch beschreibt er einfache Regeln und Vorgehensweisen, durch die es sehr einfach möglich wird, besser verständlichen und wartbaren Code zu schreiben.

\section{Ziele}
Das Hauptziel der Arbeit besteht darin, zu zeigen, wie CCD dabei unterstützen kann, besseren Quellcode zu schreiben. Dem Leser/der Leserin sollte am Ende dieser Arbeit klar sein, dass CCD für alle Stakeholder eines Softwareprojektes Vorteile bietet. Für den Kunden ergibt sich der Vorteil, dass gewünschte Änderungen leichter eingearbeitet werden können, da durch die verbesserte Lesbarkeit und Struktur, eine Änderung bzw. ein Hinzufügen von Funktionalitäten, erleichtert wird. Für das Unternehmen ergeben sich ähnliche Vorteile wie für den Kunden. Dadurch, dass es leichter ist Funktionalitäten hinzuzufügen, ist das Unternehmen wettbewerbsfähiger, da man Änderungen am Produkt oder Verbesserungen leichter einbauen kann. Für die ProgrammiererInnen wird die Arbeit durch Clean Code sehr stark vereinfacht, da durch die bessere Lesbarkeit ein Einarbeiten in den Quellcode um einiges leichter wird. Ein weiteres Ziel dieser Arbeit ist es zu zeigen, dass es selbst durch kleine Schritte möglich ist, eine enorme Verbesserung des Quellcodes zu erreichen. 

Die Arbeit ist in folgende Kapitel gegliedert:
\begin{itemize}
	\item Kapitel 1 beschäftigt sich in erster Linie mit allgemeinen Aspekten des CCD. In diesem Kapitel wird geklärt, wofür CCD steht, was Clean Code bedeutet, welche Möglichkeiten es gibt Clean Code zu schreiben und wie es möglich ist, den geschrieben Code auf die einzelnen CCD Regeln zu prüfen. Weiters wird auch kurz auf die Entstehung von CCD eingegangen und Tools und Möglichkeiten gezeigt, wie CCD in die kontinuierliche Entwicklung einfließen kann.
	\item In Kapitel 2 werden einige der in Kapitel 1 beschriebenen Clean Code Regeln beispielhaft angewandt. Diese Beispiele sind zu großen Teilen aus Open Source Frameworks und zeigen, wie die Lesbarkeit durch wenige Änderungen im Quellcode verbessert werden kann. Dabei wird im Speziellen darauf eingegangen, welche Probleme die Beachtung dieser Regeln behebt, sowie die Vorteile die sich dadurch ergeben.
	\item Kapitel 3 beschäftigt sich mit CCD im Alltag eines Entwicklungsteams und mit persönlichen Erfahrungen die im Zusammenhang mit CCD gemacht wurden. Dieses Kapitel ist eine persönliche Einschätzung, wie wertvoll CCD für den alltäglichen Gebrauch ist.
\end{itemize}

