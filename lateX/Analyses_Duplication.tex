\section{Duplizierungen beim Entwickeln von Software}
\SuperPar Eines der größten Probleme bei der Entwicklung von Software stellt die Duplizierung dar. Dabei lässt sich Duplizierung nicht nur im Code finden, sondern auch in anderen Vorgängen die für die Softwareentwicklung von Bedeutung sind. Für jeden Entwickler gibt es zahlreiche Aufgaben, welche er immer wieder erledigen muss. Diese sollten möglichst automatisiert und mit wenig Aufwand möglich sein, da dies ansonsten eine Duplizierung der Arbeit bedeuten würde.

\SuperPar Auf Code bezogen verbirgt sich Duplizierung nicht immer nur auf Bibliothek-, oder Klassenebene, sondern auch in Methoden. Dabei muss man zwischen einfacher, und logischer Duplizierung unterscheiden. Bei der einfachen Duplizierung handelt es sich um schlichtweg gleichen Code. Meist wurde dieser kopiert und nur ein wenig angepasst. Die logische Duplizierung ist meist schwieriger zu erkennen, denn in diesem Fall sind die duplizierten Stellen vom Aufbau her unterschiedlich, sie gleichen sich aber in der Aufgabe welche diese erledigen. Oft treten solche logischen Duplizierungen, wenn bei der Benennung der vorhandenen Methoden beziehungsweise Klassen nicht auf eine ausreichend offensichtliche Namensgebung geachtet wurde. Ein sehr wichtiges Prinzip hinsichtlich Codeduplizierung ist das von Dave Thomas und Andy Hunt beschrieben DRY-Prinzip (Don´t Repeat Yourself \cite{PRAG1999}).

\SuperPar Wie bereits erwähnt, ergeben sich durch die Duplizierung zahlreiche Probleme. Einerseits müssen Arbeiten doppelt erledigt werden, andererseits kann im Falle eines Fehlers auf das Beheben dieses in einem duplizierten Abschnitt vergessen werden.

\SuperPar Robert C. Martin bietet in seinem Buch Clean Code einige Möglichkeiten wodurch diese Probleme vermieden werden können. Diese sollten im folgenden Abschnitt näher betrachtet werden.

\subsection{Duplizierung boolscher Ausdrücke}
\label{cha:BadBoolStatements}
\begin{itemize}
	\item Projekt: \textit{Hibernate}
	\item Programmiersprache: \textit{Java}
	\item Betreffende Klasse: \textit{AbstractPropertyHolder}
	\item Betreffendes Paket: \textit{org.hibernate.cfg}
\end{itemize}

\SuperPar Wie bereits erwähnt, treten Codeduplizierungen nicht nur auf Bibliothek-, bzw. Klassenebene auf, sonder meist in einem viel kleineren Kontext. Bei boolschen Ausdrücken ist dies sehr oft der Fall. Eine logische Verzweigung, welche auf zum Beispiel die Validität einer Eingabe prüft, könnte Dies ist oft ein sehr subtiles Problem und kann nicht so leicht festgestellt werden. Meist ist dies bei komplexen boolschen Ausdrücken der Fall. Diese werden oft von mehreren Funktionen benötigt und daher einfach in den einzelnen Funktionen verwendet. Ein Beispiel für so einen boolschen Ausdruck befindet sich in Listing \ref{BoolStatement1}.

\begin{lstlisting}[language=Java, caption=Komplexe boolsche Ausdrücke 1 Zeile 255 - 264, label=lst:BoolStatement1]
	@Override
	public JoinColumn[] getOverriddenJoinColumn(String propertyName) {
		JoinColumn[] result = getExactOverriddenJoinColumn( propertyName );
		if ( result == null && propertyName.contains( ".collection&&element." ) ) {
			//support for non map collections where no prefix is needed
			//TODO cache the underlying regexp
			result = getExactOverriddenJoinColumn( propertyName.replace( ".collection&&element.", "."  ) );
		}
		return result;
	}
\end{lstlisting}

\SuperPar Ein paar Zeilen weiter in derselben Klasse findet sich die in Listing \ref{lst:BoolStatement2} dargestellte Methode.

\begin{lstlisting}[language=Java, caption=Komplexe boolsche Ausdrücke 2 Zeile 305 - 313, label=lst:BoolStatement2]
public JoinTable getOverriddenJoinTable(String propertyName) {
	JoinTable result = getExactOverriddenJoinTable(propertyName);
	if(result == null 
		&& propertyName.contains(".collection&&element.")){
		//support for non map collections where no prefix is needed
		//TODO cache the underlying regexp
		result = getExactOverriddenJoinTable( propertyName.replace( ".collection&&element.", "."  ) );
	}
	return result;
}
\end{lstlisting}

\SuperPar Konkret geht es in diesem Beispiel um den in Listing \ref{lst:BoolStatement3} beschriebenen boolschen Ausdruck der in dieser Klasse insgesamt drei mal vorkommt.

\begin{lstlisting}[language=Java, caption=Boolscher Audruck, label=lst:BoolStatement3]
result == null && propertyName.contains(".collection&&element.")
\end{lstlisting}

\SuperPar Wie man anhand dieser Listings leicht erkennen kann, wird dieser Ausdruck in beiden Methoden verwendet, wodurch sich eine Code Duplizierung ergibt. Dieses Problem kommt vor allem bei zukünftigen Änderungen zu Tragen. Wenn zum Beispiel für die Variable \textit{propertyName} eine \textit{XML-Zeichenkette} übergeben wird und die Überprüfung wie in Listing \ref{lst:OtherSyntaxForBool} dargestellt erfolgen müsste, würde dies eine Änderung in allen Funktionen welche dieses boolsche Statement verwenden nach sich ziehen. 

\begin{lstlisting}[language=Java, caption=Boolscher Ausdruck neu, label=lst:BoolStatement4]
 propertyName.contains("</collectionType><element>")
\end{lstlisting}

\SuperPar Falls beim Ändern der Überprüfung auf eine der Funktionen, in denen diese verwendet wird, vergessen wird, würde dies zu einem Fehler führen. Ein weiteres Problem, das sich hier wie bereits oben beschrieben ergibt, ist die Tatsache, dass dieser boolsche Kommentar ohne einen Kommentar oder ein genaues Lesen sehr schwer zu verstehen ist. Man könnte hier beide Probleme beseitigen, in dem man aus dem boolschen Audruck eine eigene Methode extrahiert. Dabei wird hier nur der zweite Teil des boolschen Ausdrucks extrahiert, da der erste Teil mit dem Nullcheck spezifisch für die einzelnen Methoden verwendet werden muss. Eine solche Methode könnte wie in Listing \ref{BoolStatement4} aussehen.

\begin{lstlisting}[language=Java, caption=Boolscher Ausdruck neu, label=lst:BoolStatement4]
private bool isPlaceholderForCollectionAndElementInPropertyName(String propertyName) {
	return propertyName.contains(".collection&&element.");
}
\end{lstlisting}

Durch ein Extrahieren der Überprüfung des Parameters \textit{propertyName} kann für diese Methode ein eigener Name gewählt werden, der klar den Zweck dieser Überprüfung vermittelt und durch diese Extrahierung wird auch die sehr problematische Codeduplizierung verhindert. Codeduplizierungen eliminiert und es bleibt nur noch die Sicherheitsüberprüfung auf null.

\subsection{Testen, Erzeugen und Verteilen von Software}

\SuperPar In der modernen Softwareentwicklung spricht man oft von \textit{Continous Delivery}. Dabei geht es um die azyklische Auslieferung von Software. Es wird dabei eine Pipeline eingerichtet, welche die einzelnen Aufgaben, welche für die Auslieferung von Software nötig sind ausführt. In dem Buch \textit{Continuous Delivery} von Eberhard Wolff erläutert der Autor seine Gedanken zum automatisieren des Prozesses vom Erstellen der Software, über das Testen bis zur Auslieferung dieser. Dies sollte für das Team möglichst einfach möglich sein und einmalig eingerichtet, für jeden zugänglich sein, sodass man möglichst schnell eine Rückmeldung erhält, ob die aktuellen Änderungen Probleme verursacht haben. Dies sollte für das Team über eine sogenannte \textit{Continous Integration} Komponente möglich sein.

\SuperPar Der automatische Prozess des Erzeugens und des Testens sollte jedoch nicht nur über die \textit{Continous Integration} Komponente ermöglicht werden. Es sollte für jeden Programmierer durch wenige Schritte möglich sein, die Software zu Erzeugen und die Tests auch auszuführen. Dies sollte möglichst durch einen einzigen Befehl, durch einen einzigen Klick, oder wenn möglich sogar automatisiert erledigt werden. Es sollten dafür keine komplizierten Operationen nötig sein, da dies zu einer Duplizierung der Arbeit führt und immer wieder Zeit benötigt. Mit modernen Entwicklungsumgebungen wie Visual Studio oder Eclipse sind meist schon Werkzeuge integriert, welche das Erstellen und das Testen von Software durch eine einfache Tastenkombination oder einen einzelnen Klick ermöglichen. Diese Features sollten daher auch verwendet werden.

\subsection{Redundante Kommentare}
\begin{itemize}
	\item Projekt: \textit{Log4Net}
	\item Programmiersprache: \textit{C\#}
	\item Betreffende Klasse: \textit{ConfigurationChangedEventArgs}
	\item Betreffender Namespace: \textit{log4net.Repository}
\end{itemize}

\SuperPar Redundante Kommentare findet man sehr häufig in den verschiedensten Projekten. Oft werden für Methoden Kommentare geschrieben, welche nicht mehr als den Namen der Methode beinhalten. Dies führt natürlich zu keiner Verbesserung der Lesbarkeit und führt im Weiteren auch zu einer Aufblähung des Codes. Sehr häufig tritt dieses Problem auch bei Vorgeschriebenen Kommentaren auf. bei denen es in Coding Conventions vorgeschrieben ist, dass jede Methode einen Header zur Dokumentation
bekommen sollte. Dabei kommt es häufig zu redundanten Kommentaren, welche keinen wirklichen Mehrwert bringen. Robert C. Martin schreibt hierzu (Clean Code, Seite 93 - 96), dass solche Regeln meist zu Verwirrung, Lügen und einer allgemeinen Unordnung führen. 

\SuperPar Wenn man nun das in Listing \ref{lst:RedundantComment} stehende Beispiel betrachtet, fällt einen sofort der Kommentar auf, welcher keine richtigen Mehrwert
für den Leser bringt. Wie Robert C. Martin erwähnt, führt dieser nur zu einer Unordnung und kann im schlimmsten Fall sogar zu einer fälschlichen Information führen,
falls der Parameter umbenannt wird und der Kommentar dafür nicht angepasst wird. Auf Grund dieser Tatsache, sollte man laut Robert C. Martin auch auf solche Regeln verzichten, da diese eben genau zu den genannten Probleme führen.

\begin{lstlisting}[language={[Sharp]C}, caption=Beispiele für überflüssige Kommentare, label=lst:RedundantComment]
/// <summary>
/// 
/// </summary>
/// <param name="configurationMessages"></param>
public ConfigurationChangedEventArgs(ICollection configurationMessages)
{
		this.configurationMessages = configurationMessages;
}
\end{lstlisting}
